{"pages":[{"title":"404","text":"","path":"404/index.html","date":"01-04","excerpt":""},{"title":"关于我","text":"","path":"about/index.html","date":"01-04","excerpt":""},{"title":"计算单数","text":"百分数转化小数 转化 转化为小数后 只需填写1,2,3,4选项,转化率填写为百分数转化后小数。 1,2为计算后的平均数以及对刷单的转化率。 3,4为商家店铺实际数据。 6为计算后达到预算需要的单数。 7为商家店铺实际的出售数量，可以作为比较数据。 8为要为商家提供的单数。 上级（同级平均）平均访客数: 上级（统计平均）转化率: 店铺（找你刷单的）的访客数: 店铺（找你刷单的）转化率: 计算 （同级平均）预计的刷单数: （找你刷单的）店铺实际单数: 你现在要给找你刷单的需要的刷单数: 7天计划总单数: 15天计划总单数:","path":"calculation/calculation.html","date":"01-04","excerpt":""},{"title":"","text":"#countbox { list-style: none; } #count,#go { width: 200px; height: 30px; border: none; background: #FF404073; } span{ display: inline-block; width: 300px; } input, textarea { background-color: transparent; color: #ff0000db; font-weight: bolder; }","path":"calculation/mycss.css","date":"01-07","excerpt":""},{"title":"","text":"function countone() { var count = document.getElementById('count') //计算按钮 count.onclick = function () { var visitorllerOne = document.getElementById('needvisitor').value, //获取需要的访客数 needconversion = document.getElementById('needconversion').value //预计转化率 quantityOne = document.getElementById('needquantity'), //获取预计刷单量 shopvisitorTwo = document.getElementById('shopvisitor').value, //获取店铺的访问量 shopConversion = document.getElementById('shopconversion').value, //获取店铺的转化率 quantityTwo = document.getElementById('shopquantity'), //获取店铺的实际销量 lastQuantity = document.getElementById('lastquantity'), //获取需要的刷单数 SevenTotal = document.getElementById('SevenTotal'); FifteenTotal = document.getElementById('FifteenTotal'); quantityOne.value = Math.round(visitorllerOne * needconversion) quantityTwo.value = Math.round(shopvisitorTwo * shopConversion) lastQuantity.value = quantityOne.value - quantityTwo.value SevenTotal.value = lastQuantity.value * 7 FifteenTotal.value = lastQuantity.value * 15 var num1 = SevenTotal.value; var num2 = 5; console.log((num1 - num2 * 7) / 7) console.log((num1 - num2 * 7) / 15) } } function countTwo() { var btn1 = document.getElementById('go') btn1.onclick = function () { var percent = document.getElementById('percent').value function toPoint(percent) { var str = percent.replace(\"%\", \"\"); str = str / 100; return str; } document.getElementById('result').value = toPoint(percent).toFixed(4); } } countone() countTwo()","path":"calculation/myjs.js","date":"01-07","excerpt":""},{"title":"分类","text":"","path":"categories/index.html","date":"01-04","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"01-04","excerpt":""},{"title":"标签","text":"","path":"tags/index.html","date":"01-04","excerpt":""}],"posts":[{"title":"gulp","text":"gulp初始化项目，生成package.json文件npm init 全局安装gulp命令行工具，只需要安装一次，在任何目录都能使用gulp命令npm install gulp-cli --global 本地安装gulp包，提供gulp的API方法，例如，task()，src()，dest()，watch()方法npm install gulp --save-dev 创建gulp的配置文件，推荐使用gulpfile作为文件名。使用gulp提供的API方法创建各种任务，例如，处理less文件，处理JS文件。在创建各种任务时，会依赖其他的包，比如，gulp-less，gulp-uglify，因此我们需要事先安装这些包。npm install gulp-less gulp-cssnano gulp-htmlmin gulp-uglify gulp-connect --save-dev gulp-less：将less文件内容编译成css内容。 gulp-cssnano：压缩css文件内容 gulp-htmlmin：压缩HTML文件内容 gulp-uglify：压缩混淆JS文件内容 gulp-connect：创建一个开发阶段所使用的服务器 练习123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354const &#123; src, dest, watch &#125; = require(\"gulp\");const uglify = require(\"gulp-uglify\")const css = require(\"gulp-cssnano\")const html = require(\"gulp-htmlmin\")//创建一个任务function task1(callback) &#123; console.log(\"执行了task1任务\") callback();&#125;exports.task1 = task1;/* F:\\HTML\\NoodeJs\\gulp\\gulpdemo&gt;gulp task1[21:52:40] Using gulpfile F:\\HTML\\NoodeJs\\gulp\\gulpdemo\\gulpfile.js[21:52:40] Starting 'task1'...执行了task1任务[21:52:40] Finished 'task1' after 5.24 ms *///处理JS文件，给JS文件附上亚索的力量！！！//cnpm install --save-dev gulp-uglify安装压缩混淆包function script() &#123; return src(\"src/index.js\") .pipe(uglify()) .pipe(dest(\"dest/\")) //压缩后的目录 dest()方法&#125;exports.script = script;/* F:\\HTML\\NoodeJs\\gulp\\gulpdemo&gt;gulp script[22:15:05] Using gulpfile F:\\HTML\\NoodeJs\\gulp\\gulpdemo\\gulpfile.js[22:15:05] Starting 'script'...[22:15:05] Finished 'script' after 134 ms */function htmlmini() &#123; return src(\"src/index.html\") .pipe(html(&#123; collapseWhitespace: true &#125;)) .pipe(dest(\"dest/\"))&#125;function cssmini() &#123; return src(\"src/index.css\") .pipe(css()) .pipe(dest(\"dest/\"))&#125;exports.css = cssmini;exports.html = htmlmini;/* F:\\HTML\\NoodeJs\\gulp\\gulpdemo&gt;gulp html[22:26:42] Using gulpfile F:\\HTML\\NoodeJs\\gulp\\gulpdemo\\gulpfile.js[22:26:42] Starting 'html'...[22:26:42] Finished 'html' after 35 msF:\\HTML\\NoodeJs\\gulp\\gulpdemo&gt;gulp css[22:26:52] Using gulpfile F:\\HTML\\NoodeJs\\gulp\\gulpdemo\\gulpfile.js[22:26:52] Starting 'css'...[22:26:52] Finished 'css' after 278 ms */","path":"2019/01/07/gulp/","date":"01-07","excerpt":"","tags":[{"name":"nood.js","slug":"nood-js","permalink":"https://bmmanmyt.github.io/tags/nood-js/"}]},{"title":"npm管理器","text":"npm 第三方包管理器为了安装第三包，需要用nom管理器。第三方平台下载 : https://www.npmjs.com/ 安装npm :npm init 创建之后，在package.json中加入private：true代表设置为私人的包，并不会公众化。 安装第三方包npm install --global http-server 安装全局http命令。 默认为最新版本，在server后@可设置版本号。 npm uninstall --global http-server 卸载全局http命令 全局安装gulpnpm install --global gulp 安装本地包npm install gulp --save-dev/-D 适用于开发阶段的包 --save 适用于开发和产品阶段 npm list 所有安装的包 gulp插件解决gulp服务器在国外下载慢的问题。方法一淘宝定制命令行工具 npm install -g cnpm --registry=https://registry.npm.taobao.org 方法二修改npm的下载仓库为淘宝镜像 npm config set registry http://registry.npm.taobao.org/ 如果要发布自己的镜像需要修改回来 npm config set registry https://registry.npmjs.org/","path":"2019/01/07/npm管理器/","date":"01-07","excerpt":"","tags":[{"name":"nood.js","slug":"nood-js","permalink":"https://bmmanmyt.github.io/tags/nood-js/"}]},{"title":"Commonjs","text":"Commonjs :Nood.js模块化规范exports 导出require 导入每个模块内部都有一个module对象，代表当前对象。 123456 exports.multiply = function(num1, num2) &#123; return num1 * num2;&#125;exports.divide = function(num1, num2) &#123; return num1 / num2;&#125; module变量： 每个模块内部都有一个module对象，代表着当前模块。它有以下属性： 12345console.log(module.id) // 模块的标识符，通常是带有绝对路径的模块文件名 console.log(module.filename) // 模块文件名，带有绝对路径 console.log(module.parent) // 调用该模块的模块 console.log(module.chilren) // 该模块调用的模块 console.log(module.exports) // 表示模块对外导出的值 exports变量： 为了方便，Node为每个模块提供了exports变量，指向module.exports， 12345678910111213 等同于：var exports = module.exports（Node隐式做了这个赋值）console.log(exports) let multiply = function(num1, num2) &#123; return num1 * num2; &#125; let divide = function(num1, num2) &#123; return num1 / num2; &#125; module.exports = &#123;&#125; var exports = module.exports 如果改变了 module.exports，但还想使用 exports.xxx 的方法暴露一些东西，1234567891011 我们需要让exports重新指向module.exportsmodule.exports = &#123;&#125;;exports = module.exports;// 常见的写法：exports = module.exports = &#123;&#125;","path":"2019/01/07/Commonjs/","date":"01-07","excerpt":"","tags":[{"name":"模块化","slug":"模块化","permalink":"https://bmmanmyt.github.io/tags/模块化/"}]},{"title":"node.js简单介绍","text":"中文API文档： http://nodejs.cn/api/英文API文档: https://nodejs.org/en/docs/命令与特殊键123456789101112node 进入交互式解析node --help 帮助信息-e 执行JS代码.break 终止正在输入的表达式.load 读取一个文件到当前会话.editor 进入编辑模式 node中的this是存在的。","path":"2019/01/07/node-js-第一天/","date":"01-07","excerpt":"","tags":[{"name":"node.js","slug":"node-js","permalink":"https://bmmanmyt.github.io/tags/node-js/"}]},{"title":"箭头函数","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;pre style=\"color:red\"&gt; // \\\\ // \\\\ // ##DDDDDDDDDDDDDDDDDDDDDD## ## DDDDDDDDDDDDDDDDDDDD ## ________ ___ ___ ___ ________ ___ ___ ___ ## hh hh ## |\\ __ \\ |\\ \\ |\\ \\ |\\ \\ |\\ __ \\ |\\ \\ |\\ \\ |\\ \\ ## hh // \\\\ hh ## \\ \\ \\|\\ /_\\ \\ \\\\ \\ \\ \\ \\ \\\\ \\ \\|\\ /_\\ \\ \\\\ \\ \\ \\ \\ \\ ## hh // \\\\ hh ## \\ \\ __ \\\\ \\ \\\\ \\ \\ \\ \\ \\\\ \\ __ \\\\ \\ \\\\ \\ \\ \\ \\ \\ ## hh hh ## \\ \\ \\|\\ \\\\ \\ \\\\ \\ \\____ \\ \\ \\\\ \\ \\|\\ \\\\ \\ \\\\ \\ \\____ \\ \\ \\ ## hh wwww hh ## \\ \\_______\\\\ \\__\\\\ \\_______\\\\ \\__\\\\ \\_______\\\\ \\__\\\\ \\_______\\\\ \\__\\ ## hh hh ## \\|_______| \\|__| \\|_______| \\|__| \\|_______| \\|__| \\|_______| \\|__| ## MMMMMMMMMMMMMMMMMMMM ## ##MMMMMMMMMMMMMMMMMMMMMM## Release 2.5.1. Powered by jinkela-core 2.3.1. \\/ \\/ &lt;/pre&gt; &lt;script&gt; /* **************************************************************** */ /* var 声明的变量会被提升，多次声明时会被覆盖。 let 声明的变量不会被提升，不可以多次声明，作用于只存在于块。 */ /* **************************************************************** */ // 使用const可以声明常量，常量不可以被更改。 /* **************************************************************** */ // 函数参数的默认值，当函数不传入参数时显示的默认值 function MY(name = \"李四\", age = \"20\") &#123; return name + age &#125; console.log(MY()) console.log(MY(\"王五\", \"15\")) /* **************************************************************** */ // 箭头函数 // 箭头函数中没有this，this的指向是windows var num = (a, b) =&gt; a + b //有两个参数 console.log(num(3, 4)) var a = () =&gt; \"hi\" //没有参数 console.log(a()) var b = name =&gt; name //只有一个参数 console.log(b(\"渣男\")) var num2 = (c, d) =&gt; c &gt; d ? c : d //两个数比较大小 console.log(num2(5, 7)) /* **************************************************************** */ //剩余操作符(...) //1.用于传入参数时不知道参数个数。 var e = (...f) =&gt; f console.log(e(1, 2, 3, 4, 5, 6, 7, 8, 9)) //测试，乘 加： var resule = (operator, ...numall) =&gt; &#123; if (operator === \"+\") &#123; let resule1 = 0 for (let i = 0; i &lt; numall.length; i++) &#123; resule1 += numall[i] &#125; return resule1 &#125; if (operator === \"*\") &#123; let resule1 = 1 for (let i = 0; i &lt; numall.length; i++) &#123; resule1 *= numall[i] &#125; return resule1 &#125; &#125; console.log(resule(\"+\", 1, 2, 3, 4)) console.log(resule(\"*\", 1, 2, 3, 4)) //2.用于展开数组 let arr1 = [1, 2, 3, 4, 5, 67, 8, 9, 7] console.log(...arr1) // 3.复制数组 let arr2 = [...arr1] console.log(arr2) /* **************************************************************** */ // 模板字面量 console.log(` --------------- --------------- || || --------------- --------------- || || --------------- --------------- 中间拼接变量时用$() `) console.log(` // \\\\ // \\\\ // ##DDDDDDDDDDDDDDDDDDDDDD## ## DDDDDDDDDDDDDDDDDDDD ## ________ ___ ___ ___ ________ ___ ___ ___ ## hh hh ## |\\ __ \\ |\\ \\ |\\ \\ |\\ \\ |\\ __ \\ |\\ \\ |\\ \\ |\\ \\ ## hh // \\\\ hh ## \\ \\ \\|\\ /_\\ \\ \\\\ \\ \\ \\ \\ \\\\ \\ \\|\\ /_\\ \\ \\\\ \\ \\ \\ \\ \\ ## hh // \\\\ hh ## \\ \\ __ \\\\ \\ \\\\ \\ \\ \\ \\ \\\\ \\ __ \\\\ \\ \\\\ \\ \\ \\ \\ \\ ## hh hh ## \\ \\ \\|\\ \\\\ \\ \\\\ \\ \\____ \\ \\ \\\\ \\ \\|\\ \\\\ \\ \\\\ \\ \\____ \\ \\ \\ ## hh wwww hh ## \\ \\_______\\\\ \\__\\\\ \\_______\\\\ \\__\\\\ \\_______\\\\ \\__\\\\ \\_______\\\\ \\__\\ ## hh hh ## \\|_______| \\|__| \\|_______| \\|__| \\|_______| \\|__| \\|_______| \\|__| ## MMMMMMMMMMMMMMMMMMMM ## ##MMMMMMMMMMMMMMMMMMMMMM## Release 2.5.1. Powered by jinkela-core 2.3.1. \\/ \\/ `) /* **************************************************************** */ // 对象属性的简写 // 对象的属性名字==属性值的时候，可以只写一个。 let g = \"渣男\" var obj = &#123; g &#125; console.log(obj.g) /* **************************************************************** */ //数据解构 let munber = [1, 2, 3, 4, 56, 7, 8, 9, 5] let [one, ...two] = munber console.log(one, two) let munber2 = [1, 2, 3, [4, 56, 7], 8, 9, 5] let [, , , [thiree]] = munber2 console.log(thiree) /* **************************************************************** */ //对象解构 let h = &#123; name: \"mengmeng\" &#125; let &#123; name &#125; = h console.log(name) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","path":"2019/01/05/箭头函数/","date":"01-05","excerpt":"","tags":[]},{"title":"JavaScript 简答题","text":"请描述一下cookies，sessionStorage和localStorage的区别？sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。 web storage和cookie的区别Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。但是Cookie也是不可以或缺的：Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生。 看下列代码输出为何？解释原因。123var a;alert(typeof a); // undefinedalert(b); // 报错 用js实现随机选取10–100之间的10个数字，存入一个数组，并排序。1234567891011121314151617181920212223function randomNub(aArray, len, min, max) &#123; if (len &gt;= (max - min)) &#123; return '超过' + min + '-' + max + '之间的个数范围' + (max - min - 1) + '个的总数'; &#125; if (aArray.length &gt;= len) &#123; aArray.sort(function(a, b) &#123; return a - b &#125;); return aArray; &#125; var nowNub = parseInt(Math.random() * (max - min - 1)) + (min + 1); for (var j = 0; j &lt; aArray.length; j++) &#123; if (nowNub == aArray[j]) &#123; randomNub(aArray, len, min, max); return; &#125; &#125; aArray.push(nowNub); randomNub(aArray, len, min, max); return aArray; &#125;var arr=[];randomNub(arr,10,10,100); 如何阻止事件冒泡和默认事件阻止事件冒泡：1234.stopPropagation();// 阻止默认事件return false;.preventDefault(); JavaScript的数据类型都有什么？看下列代码，将会输出什么?(变量声明提升)123456var foo = 1;(function()&#123; console.log(foo); // undefined var foo = 2; console.log(foo); // 2&#125;)() 怎样添加、移除、移动、复制、创建和查找节点。正则表达式构造函数var reg=new RegExp(“xxx”)与正则表达字面量var reg=//有什么不同？匹配邮箱的正则表达式？当使用RegExp()构造函数的时候，不仅需要转义引号（即\\”表示”），并且还需要双反斜杠（即\\表示一个\\）。使用正则表达字面量的效率更高。邮箱的正则匹配： var regMail = /^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+((.[a-zA-Z0-9_-]{2,3}){1,2})$/; 一个完整的URL有哪几部分组成？1.协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在”HTTP”后面的“//”为分隔符。 2.域名部分：该URL的域名部分为“www.haogu.com”。一个URL中，也可以使用IP地址作为域名使用。 3.端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口80 4.虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/” 5.文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名。 6.锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分。 7.参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“username=lisi&amp;password=24618&amp;page=1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。 请求消息和相应消息分别有哪几本部分组成？客户端发送给服务器端的HTTP请求消息由请求行（request line）、请求头部（header）、空行和请求数据四个部分组成，如下图所示。 123456789GET /index.html HTTP/1.1 Host: www.baidu.com Connection: keep-alive Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36 Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8 Accept-Encoding: gzip, deflate, br Accept-Language: zh-CN,zh;q=0.9 Cookie:BAIDUID=002E605A2EE0AA27D0B7C2295B9D0242:FG=1;BIDUPSID=002E605A2EE0AA27D0B7C2295B9D0242;PSTM=1532306024;BD_UPN=12314753;BDORZ=B490B5EBF6F3CD402E515D22BCDA1598;delPer=0;BD_HOME=0;H_PS_PSSID=1465_26911_21121_26350_26925_20719 第一部分：请求行，用来说明请求类型，要访问的资源以及所使用的HTTP版本. 请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本。GET指定请求类型为GET，/index.html为要访问的资源，该行的最后一部分说明使用的是HTTP1.1版本。 第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息。 从第二行起为请求头部，HOST将指出请求的目的地。User-Agent，服务器端和客户端脚本都能访问它,它是浏览器类型检测逻辑的重要基础.该信息由你的浏览器来定义,并且在每个请求中自动发送等等。 第三部分：空行，请求头部后面的空行是必须要有的 即使第四部分的请求数据为空，也必须有空行。 第四部分：请求数据也叫主体，可以添加任意的其他数据。 这个例子的请求数据为空。 POST请求例子，使用Charles抓取的request：123456789101112131415POST /api/students HTTP/1.1 Host: 192.168.0.130:3000 Connection: keep-alive Content-Length: 245 Cache-Control: max-age=0 Origin: http://192.168.0.130:3000 Upgrade-Insecure-Requests: 1 Content-Type: application/x-www-form-urlencoded User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36 Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8 Referer: http://192.168.0.130:3000/students/create Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9clazz=%E7%81%AB%E8%8A%B112%E6%9C%9F&amp;name=%E9%99%88%E6%A2%A6%E9%BE%99&amp;gender=%E7%94%B7&amp;age=20&amp;hobby=%E7%9D%A1%E8%A7%89&amp;hobby=%E6%89%93%E8%B1%86%E8%B1%86&amp;tel=13834569928&amp;address=%E5%8D%97%E9%98%B3&amp;remark=%E6%96%B0%E5%90%8C%E5%AD%A6&amp;date=2018-08-01 第一部分：请求行，第一行明了是post请求，以及http1.1版本。第二部分：请求头部，第二行至第六行。第三部分：空行，第七行的空行。第四部分：请求数据，第八行。 响应消息Response一般情况下，服务器接收到请求后，会对请求进行处理，然会返回给客户端一个HTTP的响应消息。HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。1234567891011121314151617181920212223242526272829HTTP/1.1 200 OK Bdpagetype: 1 Bdqid: 0xc347763400004282 Cache-Control: private Connection: Keep-Alive Content-Encoding: gzip Content-Type: text/html Cxy_all: baidu+5e802392ce41b42ad2771898f1006759 Date: Thu, 09 Aug 2018 01:36:14 GMT Expires: Thu, 09 Aug 2018 01:36:06 GMT Server: BWS/1.1 Set-Cookie: delPer=0; expires=Sat, 01-Aug-2048 01:36:06 GMT Set-Cookie: BDSVRTM=0; path=/ Set-Cookie: BD_HOME=0; path=/ Set-Cookie: H_PS_PSSID=1465_26964_21121_26350_26925_20719;path=/;domain=.baidu.com Strict-Transport-Security: max-age=172800 Vary: Accept-Encoding X-Ua-Compatible: IE=Edge,chrome=1 Transfer-Encoding: chunked&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;百度一下&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 文档内容。。。&lt;/body&gt;&lt;/html&gt; 第一部分：状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。 第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为（ok） 第二部分：消息报头，用来说明客户端要使用的一些附加信息 第二行和第三行为消息报头，Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8 第三部分：空行，消息报头后面的空行是必须的 第四部分：响应正文，服务器返回给客户端的文本信息。 空行后面的html部分为响应正文。 HTTP协议的工作原理？HTTP请求的方式有几种？分别表示什么意义？有 8 种；HTTP 1.0 提供了 GET，POST，HEAD；HTTP 1.1 有新增了 OPTIONS，PUT，DELETE，CONNECT，TRACE Ajax 的作用是什么? 如何创建一个Ajax？作用：用于浏览器与服务器进行数据交互，实现页面的局部刷新。 ######## 创建一个Ajax请求：12345678Var request = XMLHttpRequest();request.open(‘POST’, url, true); // 默认是异步请求request.onreadystatechange = function()&#123;&#125;;// 设置请求头request.setRequestHeader(‘Content-Type’, ‘application/x-www-form-urlencoded’);request.send(null); 举例描述同步和异步的区别？同步:发送一个请求,等待返回,然后再发送下一个请求异步:发送一个请求,不等待返回,随时可以再发送下一个请求 请简述一下什么是同源策略？同源策略浏览器采用同源策略，禁止页面加载或执行与自身来源不同的域的任何脚本。换句话说浏览器禁止的是来自不同源的”document”或脚本，对当前”document”读取或设置某些属性。 什么是同源URL由协议、域名、端口和路径组成，如果两个URL的协议、域名和端口相同，则表示他们同源。相反，只要协议，域名，端口有任何一个的不同，就被当作是跨域。 如何解决跨域问题？1.JSONP2.通过服务器进行设置3.使用代理服务器 请简述GET和POST请求的区别，以及它们的使用场景？安全性GET 请求会将传输数据拼接在 URL 中，并显示在浏览器地址栏中。而POST相对来说比较安全，传输的数据会被放到请求体中。 传输速度GET请求会被POST请求快一些。 传输数据量GET请求能传输的数据量比较小，因不同的浏览器而有所不同，大概 4KB左右；而POST请求能传输的数据理论上没有上限的，但由于服务器硬件资源的限制，能传输的数据量也会受影响。有时候服务器的设置也会影响能传输的数据量。 在进行Ajax请求时，如何解析请求返回的json数据使用JSON.parse()方法将json格式的字符串转换成对象（Array或Object）列举出你学过的JavaScript本地对象，内置对象和宿主对象本地对象：Object, Array,Date内置对象：global,Math宿主对象：DOM，BOM 请分别描述引用类型的数据和基本类型的数据在内存中的存储方式？基本类型的数据直接存储在变量的存储空间中；而引用类型的数据并没直接存储在变量的存储空间中，变量中存储的只是引用类型数据所在的内存地址。 在使用new操作符调用函数时，具体发生了什么事（new操作符的作用）?当我们使用 new 操作符调用函数时，函数内部会自动创建一个该类型的新对象，新对象的原型指向构造函数的prototype属性。当函数调用完成时，该对象会被自动的返回到函数外部。我们可以在函数内部通过 this 关键字使用新创建的对象。 对象的属性有几种类型？怎么定义这些属性？有 2 种，分别是：数据属性和访问器属性；定义属性的方式如下：123456789101112131415161718192021Var obj1 = &#123;Name: ‘张铭恩’Age: 20,Get adult() &#123;Return this.age &gt;= 18 ? true : false;&#125;&#125;Var obj2 = &#123;Name: ‘张铭恩’Age: 20,Count: 20000Get money() &#123;Return this.count / 100;&#125;,Set money(income) &#123;This.count = this.count + income * 100;&#125;&#125;Obj2.money; // 200;// 收入300Obj2.money = 300; 属性的特性有哪些？分别代表什么意思？数据属性的特性：value 属性值Writable 是否可以修改Enumerable 是否可以枚举Configurable 是否可以删除访问器属性的特性：Get 是否可以访问Set 是否可以修改Enumerable 是否可以枚举Configurable 是否可以删除 怎样获取属性的特性？怎样设置属性的特性？获取属性的特性：getOwnPropertyDescriptor()getOwnPropertyDescriptors()设置属性的特性:defineProperty()defineProperties() 怎样封印、冻结和禁止对象扩展？禁止扩展：preventExtensions();封印对象：seal()冻结对象：freeze()被禁止扩展对象、被封印对象和被冻结对象有什么特点？被禁止扩展对象的特点： 不能添加新属性（不可扩展） 可以删除已有属性 可以修改已有属性的值 被封印对象的特点： 不能添加新属性（不可扩展） 不能删除已有属性 可以修改已有属性的值被冻结对象的特点： 不能添加新属性（不可扩展） 不能删除已有属性 不能修改已有属性的值请简述对象属性的查找顺序？当我方法对象的属性时，JavaScript引擎首先会去对象自身的属性列表种查询，如果有，则返回；如果没有，则沿着原型对象链向下寻找。如果整个原型对象链中都没有，则返回 undefined。对象的继承方式有几种？请分别编程实现：3 种，分别是：原型对象继承、对象继承、构造函数继承；12345678910111213141516171819202122232425262728293031323334原型继承（JS默认继承方式）：function Rectangle(w, h)&#123;this.width = w;this.height = h;&#125;var rect = new Rectangle(40, 20);rect 对象默认继承了 Rectangle.prototype，间接继承了 Object.prototype。对象继承：var obj1 = &#123;...&#125;;var obj2 = Object.create(obj1, &#123;...&#125;);obj2 继承了 obj1，obj1继承 Object.prototype。构造函数继承：function Rectangle(w, h)&#123;this.width = w;this.height = h;&#125;Object.defineProperty(Rectangle.prototype, ‘getArea’, &#123;value: function()&#123;return this.width * this.height;&#125;Writable: false,Enumerable: false,Configurable: false&#125;);function Square(w)&#123;this.width = w;this.height = w;&#125;Square.prototype = Object.create(new Rectangle(), &#123;constructor: &#123;value: Square,configurable: false,enumerable: false,writable: false&#125;&#125;&#125;;","path":"2019/01/04/JavaScript-简答题/","date":"01-04","excerpt":"","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bmmanmyt.github.io/tags/JavaScript/"}]}]}