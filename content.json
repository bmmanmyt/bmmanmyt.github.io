{"pages":[{"title":"404","text":"","path":"404/index.html","date":"01-04","excerpt":""},{"title":"关于我","text":"","path":"about/index.html","date":"01-04","excerpt":""},{"title":"分类","text":"","path":"categories/index.html","date":"01-04","excerpt":""},{"title":"计算单数","text":"百分数转化小数 转化 转化为小数后 只需填写1,2,3,4选项,转化率填写为百分数转化后小数。 1,2为计算后的平均数以及对刷单的转化率。 3,4为商家店铺实际数据。 6为计算后达到预算需要的单数。 7为商家店铺实际的出售数量，可以作为比较数据。 8为要为商家提供的单数。 上级（同级平均）平均访客数: 上级（统计平均）转化率: 店铺（找你刷单的）的访客数: 店铺（找你刷单的）转化率: 计算 （同级平均）预计的刷单数: （找你刷单的）店铺实际单数: 你现在要给找你刷单的需要的刷单数: 7天计划总单数: 15天计划总单数:","path":"calculation/calculation.html","date":"01-04","excerpt":""},{"title":"","text":"#countbox { list-style: none; } #count,#go { width: 200px; height: 30px; border: none; background: #FF404073; } span{ display: inline-block; width: 300px; } input, textarea { background-color: transparent; color: #ff0000db; font-weight: bolder; }","path":"calculation/mycss.css","date":"01-07","excerpt":""},{"title":"","text":"function countone() { var count = document.getElementById('count') //计算按钮 count.onclick = function () { var visitorllerOne = document.getElementById('needvisitor').value, //获取需要的访客数 needconversion = document.getElementById('needconversion').value //预计转化率 quantityOne = document.getElementById('needquantity'), //获取预计刷单量 shopvisitorTwo = document.getElementById('shopvisitor').value, //获取店铺的访问量 shopConversion = document.getElementById('shopconversion').value, //获取店铺的转化率 quantityTwo = document.getElementById('shopquantity'), //获取店铺的实际销量 lastQuantity = document.getElementById('lastquantity'), //获取需要的刷单数 SevenTotal = document.getElementById('SevenTotal'); FifteenTotal = document.getElementById('FifteenTotal'); quantityOne.value = Math.round(visitorllerOne * needconversion) quantityTwo.value = Math.round(shopvisitorTwo * shopConversion) lastQuantity.value = quantityOne.value - quantityTwo.value SevenTotal.value = lastQuantity.value * 7 FifteenTotal.value = lastQuantity.value * 15 var num1 = SevenTotal.value; var num2 = 5; console.log((num1 - num2 * 7) / 7) console.log((num1 - num2 * 7) / 15) } } function countTwo() { var btn1 = document.getElementById('go') btn1.onclick = function () { var percent = document.getElementById('percent').value function toPoint(percent) { var str = percent.replace(\"%\", \"\"); str = str / 100; return str; } document.getElementById('result').value = toPoint(percent).toFixed(4); } } countone() countTwo()","path":"calculation/myjs.js","date":"01-07","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"01-04","excerpt":""},{"title":"标签","text":"","path":"tags/index.html","date":"01-04","excerpt":""}],"posts":[{"title":"node.js    第一天","text":"中文API文档： http://nodejs.cn/api/英文API文档: https://nodejs.org/en/docs/命令与特殊键","path":"2019/01/07/node-js-第一天/","date":"01-07","excerpt":"","tags":[{"name":"node.js","slug":"node-js","permalink":"https://bmmanmyt.github.io/tags/node-js/"}]},{"title":"箭头函数","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;pre style=\"color:red\"&gt; // \\\\ // \\\\ // ##DDDDDDDDDDDDDDDDDDDDDD## ## DDDDDDDDDDDDDDDDDDDD ## ________ ___ ___ ___ ________ ___ ___ ___ ## hh hh ## |\\ __ \\ |\\ \\ |\\ \\ |\\ \\ |\\ __ \\ |\\ \\ |\\ \\ |\\ \\ ## hh // \\\\ hh ## \\ \\ \\|\\ /_\\ \\ \\\\ \\ \\ \\ \\ \\\\ \\ \\|\\ /_\\ \\ \\\\ \\ \\ \\ \\ \\ ## hh // \\\\ hh ## \\ \\ __ \\\\ \\ \\\\ \\ \\ \\ \\ \\\\ \\ __ \\\\ \\ \\\\ \\ \\ \\ \\ \\ ## hh hh ## \\ \\ \\|\\ \\\\ \\ \\\\ \\ \\____ \\ \\ \\\\ \\ \\|\\ \\\\ \\ \\\\ \\ \\____ \\ \\ \\ ## hh wwww hh ## \\ \\_______\\\\ \\__\\\\ \\_______\\\\ \\__\\\\ \\_______\\\\ \\__\\\\ \\_______\\\\ \\__\\ ## hh hh ## \\|_______| \\|__| \\|_______| \\|__| \\|_______| \\|__| \\|_______| \\|__| ## MMMMMMMMMMMMMMMMMMMM ## ##MMMMMMMMMMMMMMMMMMMMMM## Release 2.5.1. Powered by jinkela-core 2.3.1. \\/ \\/ &lt;/pre&gt; &lt;script&gt; /* **************************************************************** */ /* var 声明的变量会被提升，多次声明时会被覆盖。 let 声明的变量不会被提升，不可以多次声明，作用于只存在于块。 */ /* **************************************************************** */ // 使用const可以声明常量，常量不可以被更改。 /* **************************************************************** */ // 函数参数的默认值，当函数不传入参数时显示的默认值 function MY(name = \"李四\", age = \"20\") &#123; return name + age &#125; console.log(MY()) console.log(MY(\"王五\", \"15\")) /* **************************************************************** */ // 箭头函数 // 箭头函数中没有this，this的指向是windows var num = (a, b) =&gt; a + b //有两个参数 console.log(num(3, 4)) var a = () =&gt; \"hi\" //没有参数 console.log(a()) var b = name =&gt; name //只有一个参数 console.log(b(\"渣男\")) var num2 = (c, d) =&gt; c &gt; d ? c : d //两个数比较大小 console.log(num2(5, 7)) /* **************************************************************** */ //剩余操作符(...) //1.用于传入参数时不知道参数个数。 var e = (...f) =&gt; f console.log(e(1, 2, 3, 4, 5, 6, 7, 8, 9)) //测试，乘 加： var resule = (operator, ...numall) =&gt; &#123; if (operator === \"+\") &#123; let resule1 = 0 for (let i = 0; i &lt; numall.length; i++) &#123; resule1 += numall[i] &#125; return resule1 &#125; if (operator === \"*\") &#123; let resule1 = 1 for (let i = 0; i &lt; numall.length; i++) &#123; resule1 *= numall[i] &#125; return resule1 &#125; &#125; console.log(resule(\"+\", 1, 2, 3, 4)) console.log(resule(\"*\", 1, 2, 3, 4)) //2.用于展开数组 let arr1 = [1, 2, 3, 4, 5, 67, 8, 9, 7] console.log(...arr1) // 3.复制数组 let arr2 = [...arr1] console.log(arr2) /* **************************************************************** */ // 模板字面量 console.log(` --------------- --------------- || || --------------- --------------- || || --------------- --------------- 中间拼接变量时用$() `) console.log(` // \\\\ // \\\\ // ##DDDDDDDDDDDDDDDDDDDDDD## ## DDDDDDDDDDDDDDDDDDDD ## ________ ___ ___ ___ ________ ___ ___ ___ ## hh hh ## |\\ __ \\ |\\ \\ |\\ \\ |\\ \\ |\\ __ \\ |\\ \\ |\\ \\ |\\ \\ ## hh // \\\\ hh ## \\ \\ \\|\\ /_\\ \\ \\\\ \\ \\ \\ \\ \\\\ \\ \\|\\ /_\\ \\ \\\\ \\ \\ \\ \\ \\ ## hh // \\\\ hh ## \\ \\ __ \\\\ \\ \\\\ \\ \\ \\ \\ \\\\ \\ __ \\\\ \\ \\\\ \\ \\ \\ \\ \\ ## hh hh ## \\ \\ \\|\\ \\\\ \\ \\\\ \\ \\____ \\ \\ \\\\ \\ \\|\\ \\\\ \\ \\\\ \\ \\____ \\ \\ \\ ## hh wwww hh ## \\ \\_______\\\\ \\__\\\\ \\_______\\\\ \\__\\\\ \\_______\\\\ \\__\\\\ \\_______\\\\ \\__\\ ## hh hh ## \\|_______| \\|__| \\|_______| \\|__| \\|_______| \\|__| \\|_______| \\|__| ## MMMMMMMMMMMMMMMMMMMM ## ##MMMMMMMMMMMMMMMMMMMMMM## Release 2.5.1. Powered by jinkela-core 2.3.1. \\/ \\/ `) /* **************************************************************** */ // 对象属性的简写 // 对象的属性名字==属性值的时候，可以只写一个。 let g = \"渣男\" var obj = &#123; g &#125; console.log(obj.g) /* **************************************************************** */ //数据解构 let munber = [1, 2, 3, 4, 56, 7, 8, 9, 5] let [one, ...two] = munber console.log(one, two) let munber2 = [1, 2, 3, [4, 56, 7], 8, 9, 5] let [, , , [thiree]] = munber2 console.log(thiree) /* **************************************************************** */ //对象解构 let h = &#123; name: \"mengmeng\" &#125; let &#123; name &#125; = h console.log(name) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","path":"2019/01/05/箭头函数/","date":"01-05","excerpt":"","tags":[]},{"title":"JavaScript 简答题","text":"请描述一下cookies，sessionStorage和localStorage的区别？sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。 web storage和cookie的区别Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。但是Cookie也是不可以或缺的：Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生。 看下列代码输出为何？解释原因。123var a;alert(typeof a); // undefinedalert(b); // 报错 用js实现随机选取10–100之间的10个数字，存入一个数组，并排序。1234567891011121314151617181920212223function randomNub(aArray, len, min, max) &#123; if (len &gt;= (max - min)) &#123; return '超过' + min + '-' + max + '之间的个数范围' + (max - min - 1) + '个的总数'; &#125; if (aArray.length &gt;= len) &#123; aArray.sort(function(a, b) &#123; return a - b &#125;); return aArray; &#125; var nowNub = parseInt(Math.random() * (max - min - 1)) + (min + 1); for (var j = 0; j &lt; aArray.length; j++) &#123; if (nowNub == aArray[j]) &#123; randomNub(aArray, len, min, max); return; &#125; &#125; aArray.push(nowNub); randomNub(aArray, len, min, max); return aArray; &#125;var arr=[];randomNub(arr,10,10,100); 如何阻止事件冒泡和默认事件阻止事件冒泡：1234.stopPropagation();// 阻止默认事件return false;.preventDefault(); JavaScript的数据类型都有什么？看下列代码，将会输出什么?(变量声明提升)123456var foo = 1;(function()&#123; console.log(foo); // undefined var foo = 2; console.log(foo); // 2&#125;)() 怎样添加、移除、移动、复制、创建和查找节点。正则表达式构造函数var reg=new RegExp(“xxx”)与正则表达字面量var reg=//有什么不同？匹配邮箱的正则表达式？当使用RegExp()构造函数的时候，不仅需要转义引号（即\\”表示”），并且还需要双反斜杠（即\\表示一个\\）。使用正则表达字面量的效率更高。邮箱的正则匹配： var regMail = /^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+((.[a-zA-Z0-9_-]{2,3}){1,2})$/; 一个完整的URL有哪几部分组成？1.协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在”HTTP”后面的“//”为分隔符。 2.域名部分：该URL的域名部分为“www.haogu.com”。一个URL中，也可以使用IP地址作为域名使用。 3.端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口80 4.虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/” 5.文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名。 6.锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分。 7.参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“username=lisi&amp;password=24618&amp;page=1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。 请求消息和相应消息分别有哪几本部分组成？客户端发送给服务器端的HTTP请求消息由请求行（request line）、请求头部（header）、空行和请求数据四个部分组成，如下图所示。 123456789GET /index.html HTTP/1.1 Host: www.baidu.com Connection: keep-alive Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36 Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8 Accept-Encoding: gzip, deflate, br Accept-Language: zh-CN,zh;q=0.9 Cookie:BAIDUID=002E605A2EE0AA27D0B7C2295B9D0242:FG=1;BIDUPSID=002E605A2EE0AA27D0B7C2295B9D0242;PSTM=1532306024;BD_UPN=12314753;BDORZ=B490B5EBF6F3CD402E515D22BCDA1598;delPer=0;BD_HOME=0;H_PS_PSSID=1465_26911_21121_26350_26925_20719 第一部分：请求行，用来说明请求类型，要访问的资源以及所使用的HTTP版本. 请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本。GET指定请求类型为GET，/index.html为要访问的资源，该行的最后一部分说明使用的是HTTP1.1版本。 第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息。 从第二行起为请求头部，HOST将指出请求的目的地。User-Agent，服务器端和客户端脚本都能访问它,它是浏览器类型检测逻辑的重要基础.该信息由你的浏览器来定义,并且在每个请求中自动发送等等。 第三部分：空行，请求头部后面的空行是必须要有的 即使第四部分的请求数据为空，也必须有空行。 第四部分：请求数据也叫主体，可以添加任意的其他数据。 这个例子的请求数据为空。 POST请求例子，使用Charles抓取的request：123456789101112131415POST /api/students HTTP/1.1 Host: 192.168.0.130:3000 Connection: keep-alive Content-Length: 245 Cache-Control: max-age=0 Origin: http://192.168.0.130:3000 Upgrade-Insecure-Requests: 1 Content-Type: application/x-www-form-urlencoded User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36 Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8 Referer: http://192.168.0.130:3000/students/create Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9clazz=%E7%81%AB%E8%8A%B112%E6%9C%9F&amp;name=%E9%99%88%E6%A2%A6%E9%BE%99&amp;gender=%E7%94%B7&amp;age=20&amp;hobby=%E7%9D%A1%E8%A7%89&amp;hobby=%E6%89%93%E8%B1%86%E8%B1%86&amp;tel=13834569928&amp;address=%E5%8D%97%E9%98%B3&amp;remark=%E6%96%B0%E5%90%8C%E5%AD%A6&amp;date=2018-08-01 第一部分：请求行，第一行明了是post请求，以及http1.1版本。第二部分：请求头部，第二行至第六行。第三部分：空行，第七行的空行。第四部分：请求数据，第八行。 响应消息Response一般情况下，服务器接收到请求后，会对请求进行处理，然会返回给客户端一个HTTP的响应消息。HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。1234567891011121314151617181920212223242526272829HTTP/1.1 200 OK Bdpagetype: 1 Bdqid: 0xc347763400004282 Cache-Control: private Connection: Keep-Alive Content-Encoding: gzip Content-Type: text/html Cxy_all: baidu+5e802392ce41b42ad2771898f1006759 Date: Thu, 09 Aug 2018 01:36:14 GMT Expires: Thu, 09 Aug 2018 01:36:06 GMT Server: BWS/1.1 Set-Cookie: delPer=0; expires=Sat, 01-Aug-2048 01:36:06 GMT Set-Cookie: BDSVRTM=0; path=/ Set-Cookie: BD_HOME=0; path=/ Set-Cookie: H_PS_PSSID=1465_26964_21121_26350_26925_20719;path=/;domain=.baidu.com Strict-Transport-Security: max-age=172800 Vary: Accept-Encoding X-Ua-Compatible: IE=Edge,chrome=1 Transfer-Encoding: chunked&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;百度一下&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 文档内容。。。&lt;/body&gt;&lt;/html&gt; 第一部分：状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。 第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为（ok） 第二部分：消息报头，用来说明客户端要使用的一些附加信息 第二行和第三行为消息报头，Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8 第三部分：空行，消息报头后面的空行是必须的 第四部分：响应正文，服务器返回给客户端的文本信息。 空行后面的html部分为响应正文。 HTTP协议的工作原理？HTTP请求的方式有几种？分别表示什么意义？有 8 种；HTTP 1.0 提供了 GET，POST，HEAD；HTTP 1.1 有新增了 OPTIONS，PUT，DELETE，CONNECT，TRACE Ajax 的作用是什么? 如何创建一个Ajax？作用：用于浏览器与服务器进行数据交互，实现页面的局部刷新。 ######## 创建一个Ajax请求：12345678Var request = XMLHttpRequest();request.open(‘POST’, url, true); // 默认是异步请求request.onreadystatechange = function()&#123;&#125;;// 设置请求头request.setRequestHeader(‘Content-Type’, ‘application/x-www-form-urlencoded’);request.send(null); 举例描述同步和异步的区别？同步:发送一个请求,等待返回,然后再发送下一个请求异步:发送一个请求,不等待返回,随时可以再发送下一个请求 请简述一下什么是同源策略？同源策略浏览器采用同源策略，禁止页面加载或执行与自身来源不同的域的任何脚本。换句话说浏览器禁止的是来自不同源的”document”或脚本，对当前”document”读取或设置某些属性。 什么是同源URL由协议、域名、端口和路径组成，如果两个URL的协议、域名和端口相同，则表示他们同源。相反，只要协议，域名，端口有任何一个的不同，就被当作是跨域。 如何解决跨域问题？1.JSONP2.通过服务器进行设置3.使用代理服务器 请简述GET和POST请求的区别，以及它们的使用场景？安全性GET 请求会将传输数据拼接在 URL 中，并显示在浏览器地址栏中。而POST相对来说比较安全，传输的数据会被放到请求体中。 传输速度GET请求会被POST请求快一些。 传输数据量GET请求能传输的数据量比较小，因不同的浏览器而有所不同，大概 4KB左右；而POST请求能传输的数据理论上没有上限的，但由于服务器硬件资源的限制，能传输的数据量也会受影响。有时候服务器的设置也会影响能传输的数据量。 在进行Ajax请求时，如何解析请求返回的json数据使用JSON.parse()方法将json格式的字符串转换成对象（Array或Object）列举出你学过的JavaScript本地对象，内置对象和宿主对象本地对象：Object, Array,Date内置对象：global,Math宿主对象：DOM，BOM 请分别描述引用类型的数据和基本类型的数据在内存中的存储方式？基本类型的数据直接存储在变量的存储空间中；而引用类型的数据并没直接存储在变量的存储空间中，变量中存储的只是引用类型数据所在的内存地址。 在使用new操作符调用函数时，具体发生了什么事（new操作符的作用）?当我们使用 new 操作符调用函数时，函数内部会自动创建一个该类型的新对象，新对象的原型指向构造函数的prototype属性。当函数调用完成时，该对象会被自动的返回到函数外部。我们可以在函数内部通过 this 关键字使用新创建的对象。 对象的属性有几种类型？怎么定义这些属性？有 2 种，分别是：数据属性和访问器属性；定义属性的方式如下：123456789101112131415161718192021Var obj1 = &#123;Name: ‘张铭恩’Age: 20,Get adult() &#123;Return this.age &gt;= 18 ? true : false;&#125;&#125;Var obj2 = &#123;Name: ‘张铭恩’Age: 20,Count: 20000Get money() &#123;Return this.count / 100;&#125;,Set money(income) &#123;This.count = this.count + income * 100;&#125;&#125;Obj2.money; // 200;// 收入300Obj2.money = 300; 属性的特性有哪些？分别代表什么意思？数据属性的特性：value 属性值Writable 是否可以修改Enumerable 是否可以枚举Configurable 是否可以删除访问器属性的特性：Get 是否可以访问Set 是否可以修改Enumerable 是否可以枚举Configurable 是否可以删除 怎样获取属性的特性？怎样设置属性的特性？获取属性的特性：getOwnPropertyDescriptor()getOwnPropertyDescriptors()设置属性的特性:defineProperty()defineProperties() 怎样封印、冻结和禁止对象扩展？禁止扩展：preventExtensions();封印对象：seal()冻结对象：freeze()被禁止扩展对象、被封印对象和被冻结对象有什么特点？被禁止扩展对象的特点： 不能添加新属性（不可扩展） 可以删除已有属性 可以修改已有属性的值 被封印对象的特点： 不能添加新属性（不可扩展） 不能删除已有属性 可以修改已有属性的值被冻结对象的特点： 不能添加新属性（不可扩展） 不能删除已有属性 不能修改已有属性的值请简述对象属性的查找顺序？当我方法对象的属性时，JavaScript引擎首先会去对象自身的属性列表种查询，如果有，则返回；如果没有，则沿着原型对象链向下寻找。如果整个原型对象链中都没有，则返回 undefined。对象的继承方式有几种？请分别编程实现：3 种，分别是：原型对象继承、对象继承、构造函数继承；12345678910111213141516171819202122232425262728293031323334原型继承（JS默认继承方式）：function Rectangle(w, h)&#123;this.width = w;this.height = h;&#125;var rect = new Rectangle(40, 20);rect 对象默认继承了 Rectangle.prototype，间接继承了 Object.prototype。对象继承：var obj1 = &#123;...&#125;;var obj2 = Object.create(obj1, &#123;...&#125;);obj2 继承了 obj1，obj1继承 Object.prototype。构造函数继承：function Rectangle(w, h)&#123;this.width = w;this.height = h;&#125;Object.defineProperty(Rectangle.prototype, ‘getArea’, &#123;value: function()&#123;return this.width * this.height;&#125;Writable: false,Enumerable: false,Configurable: false&#125;);function Square(w)&#123;this.width = w;this.height = w;&#125;Square.prototype = Object.create(new Rectangle(), &#123;constructor: &#123;value: Square,configurable: false,enumerable: false,writable: false&#125;&#125;&#125;;","path":"2019/01/04/JavaScript-简答题/","date":"01-04","excerpt":"","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bmmanmyt.github.io/tags/JavaScript/"}]},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","path":"2019/01/04/hello-world/","date":"01-04","excerpt":"","tags":[]}]}